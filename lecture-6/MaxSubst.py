# coding: utf
# Подстрока максимальной длины из разных букв
# Ввести строку и вывести ближайшую к началу подстроку максимальной длины,
# содержащую только различные символы.
# Решение: составляем словарь {номер символа:длина уникальной последовательности, начинающейся с него}
# Находим индекс с максимальной длиной, выводим срез исходной строки,
# начиная с этого символа и до его значения в словаре. Если делать в лоб,
# внутренний цикл даст сложность О(n^2). Решил с использованием динамического
# программирования - для каждого элемента длина уникальной строки,
# начинающейся с него, не меньше длины уникальной строки, начинающейся с
# предыдущего элемента, поэтому не нужно перебирать все элементы

s = raw_input();
dic = {}; # номер символа : длина уникальной последовательности, которая начинается с него
max = 0; # переменная для хранения максимальной длины последовательности
compare = 0;
for i in xrange(len(s)):
    if len(s) - i <= max:
        break;
    try:
        dic[i] = dic[i-1] - 1;
    except KeyError: # вылетает на элементе с i=0
        dic[i] = 1;
    for j in xrange(i+dic[i], len(s)):
        # compare = compare + 1;
        if s[j] not in s[i:j]:
            dic[i] += 1;
        else:
            break;
    if dic[i] > max:
        max = dic[i];
        max_index = i;
    # if i + max == len(s) - 1:
    #     break;
# for (k,v) in dic.iteritems():
#     print k,v;
# print max_index;
# print dic[max_index];
# print compare;
print s[max_index:max_index+dic[max_index]];