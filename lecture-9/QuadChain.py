# coding: utf
# Прямоугольник из цепи
# Цепь состоит из прямых отрезков различной целой ненулевой длины,
# соединённых попарно в замкнутую ломаную. 
# Ввести строку целых чисел через запятую — длины отрезков цепи. 
# Вывести YES, если цепь можно превратить в прямоугольник с вершинами 
# в четырёх различных вершинах ломаной. Если нельзя, вывести NO.
# Input:
#  1, 3, 2, 2, 4, 4
# Output:
#  YES
# Попробуем решать так:
# [0,0,0,0] - массив длин сторон (нули - начальные значения)
# [0,1,2,3] - массив индексов начала каждой их сторон (0,1,2,3) - начальные значения
# Формируем первую сторону:
# прибавляем к элементу массиву [0] по очереди элементы цепи и увеличиваем 
# индексы сторон на один. На каждом этапе проверяем, чтобы длина стороны не превзошла
# полупериметр и если не превосходит, переходим ко второй стороне. Если превосходит,
# выводим НЕТ.
# Формируем вторую сторону:
# прибавляем к элементу массива [1] по очереди элементы цепи и увеличиваем
# индексы на один. На каждом этапе сравниваем текущую длину цепи с полупериметром.
# Если сумма меньше, добавляем еще один элемент, если больше, возвращаемся к первой стороне
# (обнулив вторую сторону, текущую длину цепи вернув к длине первой стороны, уменьшив
# индексы второй и последующей сторон),
# если равна, фиксируем сторону и переходим к третьей стороне.
# Формируем четвертую сторону:
# прибавляем к элементу массива [2] по очереди элменты цепи и увеличиваем 
# индексы на один. На каждом этапе сравниваем длину третьей стороны с длиной
# первой стороны. Если меньше, продложаем увеличивать, если равна, переходим к
# четвертой стороне, если больше - обнуляем вторую и третью стороны, сбрасываем индексы
# относительно первой стороны, сбрасывем текущую длину и переходим к первой стороне.
# Формируем четвертую сторону:
# суммируем оставшиеся элементы. Если сумма равна длине второй стороны, выводим ДА, если
# меньше, выводим НЕТ, если больше - сбрасываем вторую, третью и четвертую стороны, их индексы,
# текущую длину цепи и возвращаемся к первой стороне.
